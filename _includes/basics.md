## <a name="introduction" class="anchor"></a>Introduction
Dependable is a .NET library aiming to solve reliable workflow execution problem in a more general purpose fashion. It aims to provide

- An expressive, composable programming model
- Abstraction of complex task of coordination
- Robust, scalable and extensible runtime 

## <a name="installation" class="anchor"></a>Installation
Core functionality of Dependable is available in a single module which has no dependecies. Simply install the nuget packge and we are set to go.
```sh
install-package dependable
```
## <a name="creating-an-activity" class="anchor"></a>Creating an Activity
An Activity is a unit of work that we would like to perform in a workflow. Sending an email, generating a PDF, scaling images and calling an external web service are some classic examples. They can be created from any method in a class that returns a ```Task``` or ```Task<Activity>```.

```csharp
public class Notify 
{
    public async Task Email(string from, string to, string body)
    {        
    }
}

var email = Activity.Run<Notify>(a => a.Email("alice@me.com", "bob@me.com", "hello"));
```

Dependable also provides handful of methods to compose larger worflows out of smaller activities.

### Some examples of composition
```csharp
// Runs A.Foo() and then B.Bar()
Activity.Run<A>(a => a.Foo()).Then<B>(b => b.Bar());

// Runs B.Bar() if A.Foo() fails (after specified number of retry attempts).
Activity.Run<A>(a => a.Foo()).WhenFailed(Activity.Run<B>(b => b.Bar()));

// Runs B.Bar() everytime A.Foo() throws an exception.
Activity.Run<A>(a => a.Foo()).WithExceptionFilter<B>((exception, b) => b.Bar(exception));

// Runs A.Foo() and then B.bar(). If any of them fails runs C.FooBar();
Activity
    .Sequence(
        Activity.Run<A>(a => a.Foo()), 
        Activity.Run<B>(b = b.Bar()))
    .WhenAnyFailed(Activity.Run<C>(c => c.FooBar()));

// Runs A.Foo() and then B.bar(). If all of them fails runs C.FooBar()
Activity
    .Sequence(
        Activity.Run<A>(a => a.Foo()), 
        Activity.Run<B>(b = b.Bar()))
    .WhenAllFailed(Activity.Run<C>(c => c.FooBar()));    


// Runs A.Foo() and then B.bar(). If any of them fails runs C.FooBar().
// If both of them fail runs D.Jar().
Activity
    .Sequence(
        Activity.Run<A>(a => a.Foo()), 
        Activity.Run<B>(b = b.Bar()))
    .WhenAnyFailed(Activity.Run<C>(c => c.FooBar()))
    .WhenAllFailed(Activity.Run<D>(c => d.Jar()));

// Runs A.Foo() and then B.bar(). If any of them fails runs C.FooBar();
// Otherwise runs D.Jar().
Activity
    .Sequence(
        Activity.Run<A>(a => a.Foo()), 
        Activity.Run<B>(b = b.Bar()))
    .WhenAnyFailed(Activity.Run<C>(c => c.FooBar()))
    .Then<D>(d => d.Jar());

// Runs A.Foo() and then B.Bar(). When an exception is thrown from either of them
// or any child activity they create, invoke C.Jar with exception details.
Activity
    .Sequence(
        Activity.Run<A>(a => a.Foo()), 
        Activity.Run<B>(b = b.Bar()))
    .WithExceptionFilter<C>((exception, c) => c.Jar(exception));

// Alternatively use Activity.Parallel instead of Activity.Sequence
// run specified activites in parallel.

// Runs A.Foo and B.Bar() in parallel. When both of them are complete
// runs D.Jar().
Activity
    .Parallel(
        Activity.Run<A>(a => a.Foo()), 
        Activity.Run<B>(b = b.Bar()))
    .Then<D>(d => d.Jar());
```

Activities can generate more activities. Dependable will not consider an activity as complete until all activities generated by that activity and their children and... well the whole activity tree :-) is complete.
This allows us to program activities with constructs provided in our programming language.

```csharp
public class LoanApproval
{
    public async Task<Activity> Approve(int applicantId, bool positiveCreditCheck, decimal amount)
    {
        var applicant = _repository.Load(applicantId);

        if(!positiveCreditCheck || amount > 100)        
            return Activity.Run<Notify>(n => n.Email("manager-bob@mybank.com", "info@mybank.com", "Verify"));
        else
            return Activity
                .Run<Transactions>(t => t.Credit(amount))
                .Then<Notify>(n => n.Email(applicant.Email, "info@mybank.com", "you have your money"));
    }
}

``` 

## <a name="creating-a-scheduler" class="anchor"></a>Creating a Scheduler
Mechanics of executing activities is in Dependable's scheduler. We can use ```DependableConfiguration``` to create one with desired configuration options. Typically we would run this code during application start-up and store this instance at the appdomain level. Invoking ```Scheduler.Start``` will make scheduler wait for activities and start processing them when they are available.

```csharp
var scheduler = new DependableConfiguration().CreateScheduler();
scheduler.Start();
```

## <a name="scheduling-activities" class="anchor"></a>Scheduling Activities
Once we have an activity and a scheduler, we can tell Dependable to schedule an instance of that activity using ```Schedule()``` method. When we invoke this method, it captures the arguments we specify in the method call expression and queues a request to execute that activity at some point later. In other words, calling thread of this method is not going to be blocked until the work is done because the intention is to run it in the background.

```csharp
var email = Activity.Run<Notify>(a => a.Email("alice@me.com", "bob@me.com", "hello"));
scheduler.Schedule(email);
```

## <a name="retry" class="anchor"></a>Retry
When an activity fails, we can configure Dependable to retry it. Retry configuration takes place in two places. Firstly we should tell dependable how many times the activity should be retried and interval used calculate the due time (i.e. the lag between the failure and next execution of activity). We can configure these values globally for all activities or for specific ones or both.

```csharp
// Setting retry settings globally
var scheduler = new DependableConfiguration()
                    .SetDefaultRetryCount(1)
                    .SetDefaultRetryDelay(TimeSpan.FromSeconds(5))
                    .CreateScheduler();

// Setting retry settings for a specific job
var scheduler = new DependableConfiguration()
                    .Activity<Notify>(c => c
                        .WithRetryCount(1)
                        .WithRetryDelay(TimeSpan.FromSeconds(5))                        
                    )
                    .CreateScheduler();
```


The other piece in retry process is what we call Retry Timer. It periodically scans for due items in Dependable internal structures and executes the ready ones. By default this scanning process takes place once every minute. However, we can change that in the configuration.

```csharp
var scheduler = new DependableConfiguration()
                    .SetRetryTimerInterval(TimeSpan.FromSeconds(5))
                    .CreateScheduler();
```